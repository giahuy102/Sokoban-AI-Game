+ Format của trạng thái lưu trữ:
	+ Vị trí của bot trong ma trận
	+ Vị trí của các viên kim cương trong ma trận
	+ Vị trí của các đích đến trong ma trận
	+ Một ma trận đánh dấu xem đó có phải là tường không, phải là kim cương không (để tiện cho việc kiểm tra bước đi hợp lệ). Đối với kim cương trong ma trận lưu luôn chỉ số của kim cương trong mảng chứa vị trí các kim cương.

+ Các hàm dự định viết (cho cả 2 thuật toán):
	+ can_move_up
	+ move_up
	....
	
	+ expand
	+ Hàm sinh các trạng thái kết thúc từ input

+ Có nhiều trạng thái kết thúc do một viên kim cương có thể chọn nhiều vị trí kết thúc

+ Format input:
	+ Dòng đầu chứa vị trí của bot
	+ Dòng 2 chứa số lượng viên kim cương (= số lượng vị trí kết thúc): n
	+ n dòng kế mỗi dòng chứa vị trí của n viên kim cương
	+ n dòng kế mỗi dòng chứa vị trí của n vị trí kết thúc
	+ Dòng cuối chứa ma trận đầu vào


+ Ký hiệu:
	#: tường
	.: đích
	*: hộp trong đích
	$: hộp riêng
	@: người
	+: người trong đích
	 : khoảng trống
	 
+ Tối giản lại code:
	+ Giảm các thay đổi của matrix k cần thiết

+ Sua lai cho tuan thu quy luat cua OOP

+ Hash code
+ Deadlock

+ Testcase_7: 51s với BFS
######
#    ##
#  *  #
# $*$ #
## * ##
 # * #
 # . #
 ##+##
  ###


+ https://github.com/gabrielarpino/Sokoban-Solver-AI/blob/master/sokoban.py


